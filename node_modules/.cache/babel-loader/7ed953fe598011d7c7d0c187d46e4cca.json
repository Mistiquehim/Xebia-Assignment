{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = debounce;\n\nvar _lodash = require('lodash');\n\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      result,\n      timerId,\n      lastCallTime = 0,\n      lastInvokeTime = 0,\n      leading = false,\n      maxWait = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n\n  wait = (0, _lodash.toNumber)(wait) || 0;\n\n  if ((0, _lodash.isObject)(options)) {\n    leading = !!options.leading;\n    maxWait = 'maxWait' in options && Math.max((0, _lodash.toNumber)(options.maxWait) || 0, wait);\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time; // Start the timer for the trailing edge.\n\n    timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.\n\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n    return maxWait === false ? result : nativeMin(result, maxWait - timeSinceLastInvoke);\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n\n    return !lastCallTime || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxWait !== false && timeSinceLastInvoke >= maxWait;\n  }\n\n  function timerExpired() {\n    var time = (0, _lodash.now)();\n\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    } // Restart the timer.\n\n\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    clearTimeout(timerId);\n    timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n\n    lastCallTime = lastInvokeTime = 0;\n    lastArgs = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge((0, _lodash.now)());\n  }\n\n  function debounced() {\n    var time = (0, _lodash.now)(),\n        isInvoking = shouldInvoke(time);\n    lastArgs = (0, _lodash.cloneDeep)(Array.prototype.slice.call(arguments));\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      } // Handle invocations in a tight loop.\n\n\n      clearTimeout(timerId);\n      timerId = setTimeout(timerExpired, wait);\n      return invokeFunc(lastCallTime);\n    }\n\n    return result;\n  }\n\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}","map":{"version":3,"sources":["C:/Users/negih/Desktop/Project/XebiaStarWarAssignment/star-war-app/node_modules/react-throttle/lib/classes/processors/helpers/debounce.js"],"names":["Object","defineProperty","exports","value","default","debounce","_lodash","require","func","wait","options","lastArgs","lastThis","result","timerId","lastCallTime","lastInvokeTime","leading","maxWait","trailing","TypeError","FUNC_ERROR_TEXT","toNumber","isObject","Math","max","invokeFunc","time","args","thisArg","undefined","apply","leadingEdge","setTimeout","timerExpired","remainingWait","timeSinceLastCall","timeSinceLastInvoke","nativeMin","shouldInvoke","now","trailingEdge","clearTimeout","cancel","flush","debounced","isInvoking","cloneDeep","Array","prototype","slice","call","arguments"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = debounce;\n\nvar _lodash = require('lodash');\n\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      result,\n      timerId,\n      lastCallTime = 0,\n      lastInvokeTime = 0,\n      leading = false,\n      maxWait = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = (0, _lodash.toNumber)(wait) || 0;\n  if ((0, _lodash.isObject)(options)) {\n    leading = !!options.leading;\n    maxWait = 'maxWait' in options && Math.max((0, _lodash.toNumber)(options.maxWait) || 0, wait);\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxWait === false ? result : nativeMin(result, maxWait - timeSinceLastInvoke);\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return !lastCallTime || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxWait !== false && timeSinceLastInvoke >= maxWait;\n  }\n\n  function timerExpired() {\n    var time = (0, _lodash.now)();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    clearTimeout(timerId);\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastCallTime = lastInvokeTime = 0;\n    lastArgs = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge((0, _lodash.now)());\n  }\n\n  function debounced() {\n    var time = (0, _lodash.now)(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = (0, _lodash.cloneDeep)(Array.prototype.slice.call(arguments));\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      // Handle invocations in a tight loop.\n      clearTimeout(timerId);\n      timerId = setTimeout(timerExpired, wait);\n      return invokeFunc(lastCallTime);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}"]},"metadata":{},"sourceType":"script"}